import numpy as np
import plotly.graph_objects as go

### Also just copilot but damn


def simulate_2d_current_and_waves():
    """
    Simulate the wave generated by a point charge moving in a circle in 2D.
    Visualize the resulting wave propagation using a simple retarded potential approach.
    """
    # Grid
    x = np.linspace(-10, 10, 200)
    y = np.linspace(-10, 10, 200)
    X, Y = np.meshgrid(x, y)
    frames = []
    c = 1.0  # wave speed

    # Particle trajectory: circle of radius r0, angular frequency w0
    r0 = 1.5
    w0 = 2.0
    q = 1.0  # charge

    def particle_pos(t):
        return r0 * np.cos(w0 * t), r0 * np.sin(w0 * t)

    t_vals = np.linspace(0, 6, 80)
    for i, t in enumerate(t_vals):
        # For each grid point, compute retarded time and source position
        R = np.zeros_like(X)
        E = np.zeros_like(X)
        for ix in range(X.shape[0]):
            for iy in range(X.shape[1]):
                xg, yg = X[ix, iy], Y[ix, iy]
                # Find retarded time: t' = t - |r - r'(t')|/c
                # Approximate: use t' = t - |r - r'(t)|/c (non-iterative, for visualization)
                xp, yp = particle_pos(t)
                dx = xg - xp
                dy = yg - yp
                r_dist = np.sqrt(dx**2 + dy**2)
                tret = t - r_dist / c
                # Particle position at retarded time
                xpr, ypr = particle_pos(tret)
                dxr = xg - xpr
                dyr = yg - ypr
                r_retdist = np.sqrt(dxr**2 + dyr**2)
                # Simple radiated field: proportional to acceleration, 1/r falloff
                # For circular motion, acceleration is towards center: a = w0^2 * r0
                ax = -(w0**2) * xpr
                ay = -(w0**2) * ypr
                # Project acceleration onto direction to observer
                r_hat_x = dxr / (r_retdist + 1e-8)
                r_hat_y = dyr / (r_retdist + 1e-8)
                a_proj = ax * r_hat_x + ay * r_hat_y
                # Field: E ~ (q a_proj) / r
                if r_retdist > 0.05:
                    E[ix, iy] = q * a_proj / (r_retdist + 1e-8)
                else:
                    E[ix, iy] = 0.0
        frames.append(
            go.Frame(
                data=[go.Heatmap(z=E, x=x, y=y, colorscale="Viridis", zmin=-2, zmax=2)],
                name=f"{i}",
            )
        )

    # Initial frame
    E = frames[0].data[0].z
    fig = go.Figure(
        data=[go.Heatmap(z=E, x=x, y=y, colorscale="Viridis", zmin=-2, zmax=2)],
        frames=frames,
    )
    fig.update_layout(
        title="2D Wave from Circularly Moving Charge",
        xaxis_title="x",
        yaxis_title="y",
        yaxis=dict(scaleanchor="x", scaleratio=1),
        updatemenus=[
            dict(
                type="buttons",
                showactive=False,
                y=1.05,
                x=0,
                xanchor="left",
                yanchor="bottom",
                buttons=[
                    dict(
                        label="Play",
                        method="animate",
                        args=[
                            None,
                            dict(
                                frame=dict(duration=60, redraw=True),
                                fromcurrent=True,
                                mode="immediate",
                            ),
                        ],
                    ),
                    dict(
                        label="Pause",
                        method="animate",
                        args=[
                            [None],
                            dict(
                                frame=dict(duration=0, redraw=False),
                                mode="immediate",
                                transition=dict(duration=0),
                            ),
                        ],
                    ),
                ],
            )
        ],
        sliders=[
            dict(
                steps=[
                    dict(
                        method="animate",
                        args=[
                            [f"{i}"],
                            dict(
                                mode="immediate",
                                frame=dict(duration=0, redraw=True),
                                transition=dict(duration=0),
                            ),
                        ],
                        label=f"{i+1}",
                    )
                    for i in range(len(frames))
                ],
                active=0,
                transition=dict(duration=0),
                x=0.1,
                y=0,
                currentvalue=dict(
                    font=dict(size=14), prefix="Frame: ", visible=True, xanchor="center"
                ),
                len=0.9,
            )
        ],
    )
    fig.show()


simulate_2d_current_and_waves()
